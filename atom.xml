<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vsh_fd&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-21T04:19:17.547Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Vsh_fd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【模板】树状数组</title>
    <link href="http://yoursite.com/2018/05/21/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/05/21/【模板】树状数组/</id>
    <published>2018-05-20T23:45:20.540Z</published>
    <updated>2018-05-21T04:19:17.547Z</updated>
    
    <content type="html"><![CDATA[<p>感觉是个好大的坑wa…我就简略地写写好了…其实树状数组在大部分时候仅作为线段树的替代品（执行的基本操作相似，且代码简单易懂，时空复杂度均低于线段树），那那那为什么需要线段树呢？树状数组的适用范围小啊（很小很小啊）执行基本修改查询操作已经很不错了还苛求什么呢…</p><h2 id="概念与基本性质"><a href="#概念与基本性质" class="headerlink" title="概念与基本性质"></a>概念与基本性质</h2><blockquote><p>树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。</p></blockquote><a id="more"></a><p>——以上内容摘自百度百科</p><p>举个栗子：<br>设原数组为A，树状数组为C，则</p><blockquote><p>C1 = A1<br>C2 = A1 + A2<br>C3 = A3<br>C4 = A1 + A2 + A3 + A4<br>C5 = A5<br>C6 = A5 + A6<br>C7 = A7<br>C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8<br>…<br>C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 + A11 + A12 + A13 + A14 + A15 + A16</p></blockquote><p>观察下图：</p><p><img src="https://s1.ax1x.com/2018/05/20/Cg8RqH.png" alt="Cg8RqH.png"></p><p>我们可以发现，i 号节点管辖的范围是 2 ^ k（k 是 i 的二进制末尾 0 的个数），区间最后一个元素必然是 Ai<br>显然，Cn=A(n – 2 ^ k + 1) + … + An</p><p>那么，问题来了：<br>如何求出 2 ^ k 的值呢？</p><p>这时需要引进一个特殊的函数 lowbit( )…lowb…it..（ 卡在奇怪的地方.jpg ）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数 <del>巧妙</del> 地利用了机器补码的特性，计算出了 x 二进制最低位 1 所代表的值，即 2 ^ k 的值。</p><p>然后我们就可以借助它 <del>偷税</del> 愉悦地完成接下来的操作了！！</p><hr><h2 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h2><h3 id="单点修改，区间查询"><a href="#单点修改，区间查询" class="headerlink" title="单点修改，区间查询"></a>单点修改，区间查询</h3><p>最基础的树状数组</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">int</span> n,m,t[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">'9'</span> <span class="keyword">or</span> ch&lt;<span class="string">'0'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;=<span class="string">'9'</span> <span class="keyword">and</span> ch&gt;=<span class="string">'0'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;      <span class="comment">//x 二进制最低位 1 所对应的值</span></span><br><span class="line">    <span class="keyword">return</span> x &amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;       <span class="comment">//单点修改</span></span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;       <span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;      <span class="comment">//区间查询</span></span><br><span class="line">    <span class="keyword">return</span> sum(r)-sum(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        x=read();</span><br><span class="line">        add(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r;</span><br><span class="line">        opt=read(),l=read(),r=read();</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add(l,r);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.org/problemnew/show/P3374" target="_blank" rel="noopener">洛谷 P3374 【模板】树状数组 1</a></p><h3 id="区间修改，单点查询"><a href="#区间修改，单点查询" class="headerlink" title="区间修改，单点查询"></a>区间修改，单点查询</h3><p>其实树状数组本身并不支持区间修改，但是运用 <del>人类智慧</del> 我们可以发现通过差分数组（d[ i ] = a[ i ] - a[ i - 1 ] , a[ 0 ] = 0）可以将问题转换为<strong>单点修改，区间查询</strong></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">'9'</span> <span class="keyword">or</span> ch&lt;<span class="string">'0'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> <span class="keyword">and</span> ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line">ll t[<span class="number">500050</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">val</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看起来和上一种操作没什么不同啊</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    ll now,tmp=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        now=read();</span><br><span class="line">        add(i,now-tmp);      <span class="comment">//重点在这，每次存的数都是差分后的</span></span><br><span class="line">        tmp=now;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt;</span><br><span class="line">        opt=read();</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">int</span> x,y,k;</span><br><span class="line">                x=read(),y=read(),k=read();</span><br><span class="line">                add(x,k);</span><br><span class="line">                add(y+<span class="number">1</span>,-k);         <span class="comment">//只需修改区间两端（中间差值不变）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">int</span> z;</span><br><span class="line">                z=read();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,val(z));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.org/problemnew/show/P3368" target="_blank" rel="noopener">洛谷 P3368 【模板】树状数组 2</a></p><h3 id="区间修改，区间查询"><a href="#区间修改，区间查询" class="headerlink" title="区间修改，区间查询"></a>区间修改，区间查询</h3><p>这是树状数组最常用的操作，也是用线段树最难打的（怕是常用的原因）<br>我们参考<strong>区间修改，单点查询</strong>的操作，只要求出val()函数的前缀和，就可以实现复杂度为 O( log n )的区间查询了</p><p>设原数组为 a，d 为 a 的差分数组，欲求 a 的前缀和</p><blockquote><p>a[ 1 ] + a[ 2 ] + a[ 3 ] + … + a[ n ]<br>= (d[ 1 ]) + (d[ 1 ] + d[ 2 ]) + (d[ 1 ] + d[ 2 ] + d[ 3 ]) + … +(d[ 1 ] + d[ 2 ] + … + d[ n ])<br>= d[ 1 ] · n + d[ 2 ] · (n - 1) + … +d[ n ]<br>= n · (d[ 1 ] + d[ 2 ] + … +d[ n ]) - (0 · d[ 1 ] + 1 · d[ 2 ] + … + (n - 1) · d[ n ])</p></blockquote><p>所以我们还要再维护一个 d2，使 d2[ i ] = (i - 1) · d[ i ]，每当修改 d 时就修改一下 d2，复杂度就不会改变</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>就不用什么注释了…吧？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll i,j,n,m,a[<span class="number">200050</span>],c[<span class="number">200050</span>],c2[<span class="number">200050</span>],x,l,r,w,ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">'9'</span> <span class="keyword">or</span> ch&lt;<span class="string">'0'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> <span class="keyword">and</span> ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lowbit</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x=x+lowbit(x))</span><br><span class="line">        c[x]=c[x]+w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(ll x,ll w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x=x+lowbit(x))</span><br><span class="line">        c2[x]=c2[x]+w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">val</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x&gt;<span class="number">0</span>;x=x-lowbit(x))</span><br><span class="line">        ans=ans+c[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">val2</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x&gt;<span class="number">0</span>;x=x-lowbit(x))</span><br><span class="line">        ans=ans+c2[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        a[i]=read();</span><br><span class="line">        add(i,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">        add2(i,(i<span class="number">-1</span>)*(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    m=read();</span><br><span class="line">    rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        x=read();</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            l=read(),r=read(),w=read();</span><br><span class="line">            add(l,w);</span><br><span class="line">            add(r+<span class="number">1</span>,-w);</span><br><span class="line">            add2(l,w*(l<span class="number">-1</span>));</span><br><span class="line">            add2(r+<span class="number">1</span>,-w*r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l=read(),r=read();</span><br><span class="line">            ans=r*val(r)-val2(r);</span><br><span class="line">            ans=ans-((l<span class="number">-1</span>)*val(l<span class="number">-1</span>)-val2(l<span class="number">-1</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><a href="http://codevs.cn/problem/1082/" target="_blank" rel="noopener">CodeVS 1082 线段树练习 3</a><br>为什么难度是大师啊喂</p><hr><h2 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h2><p>当然，树状数组这么有用（代码量小）的数据结构，怎么会少了矩阵呢？<del>为什么我要新开一个标题啊…</del></p><p>在一维树状数组中，tree[ x ] 记录的是右端点为 x、长度为 lowbit( x ) 的区间的区间和。<br>那么在二维树状数组中，可以类似地定义 tree[ x ][ y ] 记录的是右下角为 (x, y)，高为 lowbit( x ), 宽为 lowbit( y ) 的区间的区间和。</p><p>嘛，具体操作什么的（我好懒啊）前两种很好懂啊… <del>自己找度娘吧</del><br>至于区间修改 + 区间查询，可以参考我写的 <a href="https://vsh-fd.github.io/2018/05/16/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%A6%E5%81%8F%E6%A0%91/" target="_blank" rel="noopener">【题解】上帝造题的七分钟（二维树状数组）</a></p><p>那…就写到这吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉是个好大的坑wa…我就简略地写写好了…其实树状数组在大部分时候仅作为线段树的替代品（执行的基本操作相似，且代码简单易懂，时空复杂度均低于线段树），那那那为什么需要线段树呢？树状数组的适用范围小啊（很小很小啊）执行基本修改查询操作已经很不错了还苛求什么呢…&lt;/p&gt;
&lt;h2 id=&quot;概念与基本性质&quot;&gt;&lt;a href=&quot;#概念与基本性质&quot; class=&quot;headerlink&quot; title=&quot;概念与基本性质&quot;&gt;&lt;/a&gt;概念与基本性质&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="模板" scheme="http://yoursite.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【模板】左偏树（可并堆）</title>
    <link href="http://yoursite.com/2018/05/16/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2018/05/16/【模板】左偏树/</id>
    <published>2018-05-16T12:30:19.078Z</published>
    <updated>2018-05-20T06:51:18.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念与基本性质"><a href="#概念与基本性质" class="headerlink" title="概念与基本性质"></a>概念与基本性质</h3><blockquote><p>左偏树(Leftist Tree)是一种可并堆的实现，是具有左偏性质的堆有序二叉树</p></blockquote><ul><li><p>可并堆(Mergeable Heap)是一种抽象数据类型，它除了支持优先队列的三个基本操作(Insert, Minimum,Delete-Min)，还支持一个额外的操作——合并操作。</p></li><li><p>左偏性质是为了使我们可以以更小的代价在优先队列的其它两个基本操作（插入节点、删除最小节点）进行后维持堆性质。</p></li></ul><blockquote><p>左偏树是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针(left, right)外，还有两个属性，键值(key)和距离(dist)<br><a id="more"></a>节点的键值小于或等于它的左右子节点的键值（小根）<br>节点的左子节点的距离不小于右子节点的距离（左偏性质）<br>节点的距离等于它的右子节点的距离加1</p></blockquote><hr><h3 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h3><blockquote><ol><li>合并 - merge</li><li>查询堆最小值 - find</li><li>删除（并于查询） - erase</li></ol></blockquote><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">101000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Leftist</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lch,rch,key,fa,dist;</span><br><span class="line">&#125;h[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span> <span class="keyword">or</span> ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> <span class="keyword">and</span> ch&lt;=<span class="string">'9'</span>)&#123;x=<span class="number">10</span>*x+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">int</span> tmp=x;x=y;y=tmp;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;       <span class="comment">//合并操作</span></span><br><span class="line"><span class="keyword">if</span>(!u <span class="keyword">or</span> !v) <span class="keyword">return</span> u+v;</span><br><span class="line"><span class="keyword">if</span>(h[u].key&gt;h[v].key <span class="keyword">or</span> (h[u].key==h[v].key <span class="keyword">and</span> u&gt;v)) swap(u,v);</span><br><span class="line"><span class="keyword">int</span> &amp;ul=h[u].lch,&amp;ur=h[u].rch;</span><br><span class="line">ur=merge(ur,v);</span><br><span class="line">h[ur].fa=u;</span><br><span class="line"><span class="keyword">if</span>(h[ul].dist&lt;h[ur].dist) swap(ul,ur);</span><br><span class="line">h[u].dist=h[ur].dist+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;     <span class="comment">//删除操作</span></span><br><span class="line"><span class="keyword">int</span> ul=h[u].lch,ur=h[u].rch;</span><br><span class="line">h[u].key=<span class="number">-1</span>;h[ul].fa=<span class="number">0</span>;h[ur].fa=<span class="number">0</span>;</span><br><span class="line">merge(ul,ur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;         <span class="comment">//查询操作</span></span><br><span class="line"><span class="keyword">return</span> h[x].fa?find(h[x].fa):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">h[<span class="number">0</span>].dist=<span class="number">-1</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,n)</span><br><span class="line">h[i].key=read();</span><br><span class="line">rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line"><span class="keyword">int</span> opt,x,y;</span><br><span class="line">opt=read(),x=read();</span><br><span class="line"><span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">y=read();</span><br><span class="line"><span class="keyword">if</span>(h[x].key!=<span class="number">-1</span> &amp;&amp; h[y].key!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> p=find(x),q=find(y);</span><br><span class="line"><span class="keyword">if</span>(p!=q) merge(p,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>(h[x].key==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=find(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h[p].key);</span><br><span class="line">erase(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://www.luogu.org/problemnew/show/P3377" target="_blank" rel="noopener">洛谷 P3377 【模板】左偏树（可并堆）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念与基本性质&quot;&gt;&lt;a href=&quot;#概念与基本性质&quot; class=&quot;headerlink&quot; title=&quot;概念与基本性质&quot;&gt;&lt;/a&gt;概念与基本性质&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;左偏树(Leftist Tree)是一种可并堆的实现，是具有左偏性质的堆有序二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可并堆(Mergeable Heap)是一种抽象数据类型，它除了支持优先队列的三个基本操作(Insert, Minimum,Delete-Min)，还支持一个额外的操作——合并操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左偏性质是为了使我们可以以更小的代价在优先队列的其它两个基本操作（插入节点、删除最小节点）进行后维持堆性质。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;左偏树是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针(left, right)外，还有两个属性，键值(key)和距离(dist)&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://yoursite.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="左偏树" scheme="http://yoursite.com/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【模板】莫队算法</title>
    <link href="http://yoursite.com/2018/05/11/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/11/【模板】莫队算法/</id>
    <published>2018-05-11T10:36:57.169Z</published>
    <updated>2018-05-18T15:02:14.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p><del>莫队算法，简单说就是基于分块进行暴力</del></p><blockquote><p>莫队算法，是由前国家队队长莫涛在役时创造的，为数不多几种在役选手在比赛或平时训练中创造并广为流传使用的算法之一。</p></blockquote><p>此算法在OI界具有极高的人气，据说能解决一切区间处理问题，<del>当然我这种蒟蒻却只能板子题做做</del>，让我们通过下面的题目简单了解一下莫队算法。<br><a id="more"></a></p><hr><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>有 n 个物品，分属于不同的类别，给出m个区间，求在各个区间中连续两次取出相同类别的物品的概率，最简分数表示，若概率为0则输出0/1。（n,m&lt;=50000）</p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，我们需要两个指针 l 和 r 来指示当前区间的位置，用 sum[ ] 数组存放当前区间各类别数量，ans 为区间结果，ans 的分母是所有的组合数 (r - l + 1) (r - l + 1)（为什么不是 (r - l + 1) (r - l) 呢？<del>我也不知道，题目数据就是这样的。。</del>），而分子是各个类别的sum[ ]的平方的累加和，根据其中任意一个区间的 ans 求出相邻区间的 ans。</p><blockquote><p>这里相邻区间定义为当前区间的 l - 1 或 l + 1 或 r - 1 或 r + 1<br>以 l + 1 为例，如下图：<br><img src="https://s1.ax1x.com/2018/05/11/C0oiGD.png" alt="C0oiGD.png"><br>我们将 l + 1,此时 sum[green] - 1，区间总数也 - 1，这时你会发现改变一次的时间复杂度竟然是O( 1 )？！<br>其他的改变也是同理</p></blockquote><p>当然这样是远远不够的，若是逐个区间暴力枚举，复杂度是O( n ^ 2 )，太高了呀<br>这时需要引入变量 unit = sqrt( n )，用它来进行分块（将 n 分为 sqrt( n ) 个区域），并用 ad[ i ] 来存储 i 所在的区间，这样，进行指针跳动时，最多只需要 2 * sqrt( n ) 次就能到达目标，大大优于之前的 n 次。</p><p>最后再次致敬莫涛大神！！</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50050</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll m,ll n)</span></span>&#123;<span class="keyword">while</span>(m&gt;<span class="number">0</span>)&#123;ll c=n%m;n=m;m=c;&#125;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow2</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mo</span>&#123;</span><span class="keyword">int</span> l,r,cnt;ll A,B;&#125;ask[MAXN];   <span class="comment">//存储区间信息</span></span><br><span class="line"><span class="comment">//A,B分别存储结果的分子和分母</span></span><br><span class="line"><span class="keyword">int</span> n,m,col[MAXN],unit,ad[MAXN];</span><br><span class="line">ll sum[MAXN],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Mo a,Mo b)</span></span>&#123;    <span class="comment">//优化时间复杂度</span></span><br><span class="line"><span class="keyword">return</span> ad[a.l]==ad[b.l]?a.r&lt;b.r:a.l&lt;b.l;</span><br><span class="line">&#125;       <span class="comment">//左指针为第一关键字</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Mo a,Mo b)</span></span>&#123;<span class="keyword">return</span> a.cnt&lt;b.cnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">revise</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span></span>&#123;     <span class="comment">//每次改变并维护ans和sum[ ]</span></span><br><span class="line">ans-=pow2(sum[col[x]]);</span><br><span class="line">sum[col[x]]+=add;</span><br><span class="line">ans+=pow2(sum[col[x]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">unit=<span class="built_in">sqrt</span>(n);</span><br><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">col[i]=read();</span><br><span class="line">ad[i]=i/unit+<span class="number">1</span>;     <span class="comment">//分块</span></span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">ask[i].l=read(),ask[i].r=read();</span><br><span class="line">ask[i].cnt=i;          <span class="comment">//记录原顺序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(ask+<span class="number">1</span>,ask+m+<span class="number">1</span>,cmp1);     <span class="comment">//减少指针总变换次数</span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,m)&#123;   <span class="comment">//执行操作</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;ask[i].l) revise(l,<span class="number">-1</span>),++l;</span><br><span class="line"><span class="keyword">while</span>(l&gt;ask[i].l) revise(l<span class="number">-1</span>,<span class="number">1</span>),--l;</span><br><span class="line"><span class="keyword">while</span>(r&lt;ask[i].r) revise(r+<span class="number">1</span>,<span class="number">1</span>),++r;</span><br><span class="line"><span class="keyword">while</span>(r&gt;ask[i].r) revise(r,<span class="number">-1</span>),--r;</span><br><span class="line"><span class="keyword">if</span>(ask[i].l==ask[i].r)&#123;      <span class="comment">//输出0/1</span></span><br><span class="line">ask[i].A=<span class="number">0</span>;</span><br><span class="line">ask[i].B=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ask[i].A=ans-(ask[i].r-ask[i].l+<span class="number">1</span>);</span><br><span class="line">ask[i].B=<span class="number">1L</span>L*(ask[i].r-ask[i].l+<span class="number">1</span>)*(ask[i].r-ask[i].l);</span><br><span class="line">ll tmp=gcd(ask[i].A,ask[i].B);     <span class="comment">//最简</span></span><br><span class="line">ask[i].A/=tmp;</span><br><span class="line">ask[i].B/=tmp;</span><br><span class="line">&#125;</span><br><span class="line">sort(ask+<span class="number">1</span>,ask+m+<span class="number">1</span>,cmp2);     <span class="comment">//按照原排序输出</span></span><br><span class="line">rep(i,<span class="number">1</span>,m)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,ask[i].A,ask[i].B);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">BZOJ 2038 [2009国家集训队]小Z的袜子(hose)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法介绍&quot;&gt;&lt;a href=&quot;#算法介绍&quot; class=&quot;headerlink&quot; title=&quot;算法介绍&quot;&gt;&lt;/a&gt;算法介绍&lt;/h3&gt;&lt;p&gt;&lt;del&gt;莫队算法，简单说就是基于分块进行暴力&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;莫队算法，是由前国家队队长莫涛在役时创造的，为数不多几种在役选手在比赛或平时训练中创造并广为流传使用的算法之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此算法在OI界具有极高的人气，据说能解决一切区间处理问题，&lt;del&gt;当然我这种蒟蒻却只能板子题做做&lt;/del&gt;，让我们通过下面的题目简单了解一下莫队算法。&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://yoursite.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="莫队" scheme="http://yoursite.com/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【模板】非旋Treap</title>
    <link href="http://yoursite.com/2018/05/09/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%9D%9E%E6%97%8BTreap/"/>
    <id>http://yoursite.com/2018/05/09/【模板】非旋Treap/</id>
    <published>2018-05-09T11:37:34.082Z</published>
    <updated>2018-05-18T15:02:35.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念与基本性质"><a href="#概念与基本性质" class="headerlink" title="概念与基本性质"></a>概念与基本性质</h3><blockquote><p>Treap = Tree + Heap，即是一棵同时满足二叉搜索树和堆性质的二叉树<br>Treap 有一个随机附加域满足堆的性质，其结构相当于以随机数据插入的二叉搜索树<br>其基本操作的期望时间复杂度为 O(log n)</p></blockquote><p>相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。</p><a id="more"></a><hr><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote><ol><li>插入和删除</li><li>访问某位置</li><li>查询某数所在的位置</li></ol></blockquote><hr><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>本题目的是构造名次树来维护一个有序序列<br>为了在保证堆的性质的同时进行如上操作，我们引入下列函数：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cut</span><span class="params">(u, k)</span></span>      <span class="comment">//将以 u 为根节点的子树在第 k 个节点后切开，并返回切开后两树根节点。</span></span><br><span class="line"><span class="function"><span class="title">merge</span><span class="params">(l, r)</span></span>    <span class="comment">//在维护堆性质的同时将的两棵 Treap 合并为一棵，并返回合并后的根节点。</span></span><br></pre></td></tr></table></figure></p><p>每次cut的位置大概如下：<br><img src="https://s1.ax1x.com/2018/05/09/CwPhzn.png" alt="CwPhzn.png"></p><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><blockquote><p>插入 - insert = cut + merge + merge<br>删除 - delete = split + split + merge ⇒ O(log n)<br>排名查询/数值查询 - search ：通过二叉排序树的性质进行查找<br>前驱 - last：将所有比 x 小的数切下，找到其中最大的数后，再合并<br>后继 - next：将所有比 x 小的数（包括）切下，在剩下的树中找出最小的数后，再合并</p></blockquote><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span>&#123;</span>     <span class="comment">//记录节点状态</span></span><br><span class="line"><span class="keyword">int</span> l,r,val,siz,heap;</span><br><span class="line"><span class="comment">//l,r为节点左右子树，val节点数值 ，siz节点子树大小，heap随机生成</span></span><br><span class="line">&#125; t[<span class="number">100100</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aft</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll f=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">do</span>&#123;ch=getchar();<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(ch&lt;<span class="string">'0'</span> <span class="keyword">or</span> ch&gt;<span class="string">'9'</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> <span class="keyword">and</span> ch&lt;=<span class="string">'9'</span>);</span><br><span class="line"><span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//更新以u为根的子树的siz</span></span><br><span class="line">t[u].siz=t[t[u].l].siz+t[t[u].r].siz+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> aft <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//从以u为根的子树上割下k个点</span></span><br><span class="line">aft ans=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//记录切割后左右子树的根节点</span></span><br><span class="line"><span class="keyword">if</span>(!u) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">int</span> lsize=t[t[u].l].siz+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(k&gt;=lsize)&#123;<span class="comment">//若需要切下的点比整个左子树多，从右子树继续割</span></span><br><span class="line">ans=cut(t[u].r,k-lsize);</span><br><span class="line">t[u].r=ans.l;</span><br><span class="line">ans.l=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans=cut(t[u].l,k);</span><br><span class="line">t[u].l=ans.r;</span><br><span class="line">ans.r=u;</span><br><span class="line">&#125;</span><br><span class="line">update(u);<span class="comment">//更新以u为根节点的子树的siz</span></span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//返回左右子树根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;       <span class="comment">//将两棵树合并（按照heap值（小根堆））并返回根节点</span></span><br><span class="line"><span class="keyword">if</span>(!l) <span class="keyword">return</span> r;<span class="comment">//若左子树为空，返回右子树</span></span><br><span class="line"><span class="keyword">if</span>(!r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(t[l].heap&lt;t[r].heap)&#123;    <span class="comment">//若左子树根节点heap比右子树小，将右子树与左子树的右儿子merge</span></span><br><span class="line">t[l].r=merge(t[l].r,r);</span><br><span class="line">update(l);</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//左子树与右子树左儿子merge</span></span><br><span class="line">t[r].l=merge(l,t[r].l);</span><br><span class="line">update(r);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;    <span class="comment">//查询有多少个数严格比x小</span></span><br><span class="line"><span class="keyword">int</span> tmp=root,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tmp)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;t[tmp].val)&#123;</span><br><span class="line">ans+=t[t[tmp].l].siz+<span class="number">1</span>;</span><br><span class="line">tmp=t[tmp].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tmp=t[tmp].l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//插入操作</span></span><br><span class="line">t[++cnt].val=x;</span><br><span class="line">t[cnt].heap=rand();  <span class="comment">//随机生成heap值，使树保持相对平衡</span></span><br><span class="line">t[cnt].siz=<span class="number">1</span>;</span><br><span class="line">aft p=cut(root,rank(x));</span><br><span class="line"><span class="comment">//查找x在树中的rank，将比x小的数从树中切下</span></span><br><span class="line">root=merge(merge(p.l,cnt),p.r);</span><br><span class="line"><span class="comment">//先将x与左子树合并，再将左子树和右子树合并，并更新根节点Root</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;      <span class="comment">//删除操作</span></span><br><span class="line">aft p1=cut(root,rank(x));</span><br><span class="line">aft p2=cut(p1.r,<span class="number">1</span>);</span><br><span class="line">root=merge(p1.l,p2.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//在以u为根节点的树中，找第x小的数</span></span><br><span class="line"><span class="keyword">int</span> tmp=u;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> val=t[t[tmp].l].siz+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x==val) <span class="keyword">return</span> t[tmp].val;</span><br><span class="line"><span class="keyword">if</span>(x&lt;val) tmp=t[tmp].l;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x-=val;</span><br><span class="line">tmp=t[tmp].r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sma</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//查找第一个比x小的数</span></span><br><span class="line">aft p=cut(root,rank(x));<span class="comment">//将所有比x小的数切下</span></span><br><span class="line"><span class="keyword">int</span> ans=find(p.l,t[p.l].siz);<span class="comment">//查询切下的数中最大的</span></span><br><span class="line">root=merge(p.l,p.r);          <span class="comment">//合并</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lar</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;      <span class="comment">//查找第一个比x大的数</span></span><br><span class="line">aft p=cut(root,rank(x+<span class="number">1</span>));<span class="comment">//将所有比x小的数（包括）切下</span></span><br><span class="line"><span class="keyword">int</span> ans=find(p.r,<span class="number">1</span>);<span class="comment">//查询剩下的数中最小的</span></span><br><span class="line">root=merge(p.l,p.r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read();</span><br><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line"><span class="keyword">int</span> opt,x;</span><br><span class="line">opt=read(),x=read();</span><br><span class="line"><span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: ins(x); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: del(x); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rank(x)+<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find(root,x)); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sma(x)); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lar(x)); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://www.luogu.org/problemnew/show/P3369" target="_blank" rel="noopener">洛谷 P3369 【模板】普通平衡树（Treap/SBT）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念与基本性质&quot;&gt;&lt;a href=&quot;#概念与基本性质&quot; class=&quot;headerlink&quot; title=&quot;概念与基本性质&quot;&gt;&lt;/a&gt;概念与基本性质&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Treap = Tree + Heap，即是一棵同时满足二叉搜索树和堆性质的二叉树&lt;br&gt;Treap 有一个随机附加域满足堆的性质，其结构相当于以随机数据插入的二叉搜索树&lt;br&gt;其基本操作的期望时间复杂度为 O(log n)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。&lt;/p&gt;
    
    </summary>
    
      <category term="模板" scheme="http://yoursite.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="平衡树,Treap" scheme="http://yoursite.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91-Treap/"/>
    
  </entry>
  
  <entry>
    <title>【杂谈】Hello World!</title>
    <link href="http://yoursite.com/2018/05/08/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Hello%20World!/"/>
    <id>http://yoursite.com/2018/05/08/【杂谈】Hello World!/</id>
    <published>2018-05-08T10:12:24.224Z</published>
    <updated>2018-05-16T12:03:31.153Z</updated>
    
    <content type="html"><![CDATA[<p>经过了整整一天的调试<br><del>在@<a href="https://xianyu626.github.io/" target="_blank" rel="noopener">北咸冥鱼</a> 的帮助下</del><br>博客总算是建好了<br>接下来应该会发一些算法题解之类的吧…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过了整整一天的调试&lt;br&gt;&lt;del&gt;在@&lt;a href=&quot;https://xianyu626.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;北咸冥鱼&lt;/a&gt; 的帮助下&lt;/del&gt;&lt;br&gt;博客总算是建好了&lt;br&gt;接下来应该会发一些算法
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
