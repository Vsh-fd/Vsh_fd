<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【模板】左偏树（可并堆）</title>
      <link href="/2018/05/16/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
      <url>/2018/05/16/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
      <content type="html"><![CDATA[<h3 id="概念与基本性质"><a href="#概念与基本性质" class="headerlink" title="概念与基本性质"></a>概念与基本性质</h3><blockquote><p>左偏树(Leftist Tree)是一种可并堆的实现，是具有左偏性质的堆有序二叉树</p></blockquote><ul><li><p>可并堆(Mergeable Heap)是一种抽象数据类型，它除了支持优先队列的三个基本操作(Insert, Minimum,Delete-Min)，还支持一个额外的操作——合并操作。</p></li><li><p>左偏性质是为了使我们可以以更小的代价在优先队列的其它两个基本操作（插入节点、删除最小节点）进行后维持堆性质。</p></li></ul><blockquote><p>左偏树是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针(left, right)外，还有两个属性，键值(key)和距离(dist)<br><a id="more"></a>节点的键值小于或等于它的左右子节点的键值（小根）<br>节点的左子节点的距离不小于右子节点的距离（左偏性质）<br>节点的距离等于它的右子节点的距离加1</p></blockquote><hr><h4 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h4><blockquote><ol><li>合并 - merge</li><li>查询堆最小值 - find</li><li>删除（并于查询） - erase</li></ol></blockquote><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">101000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Leftist</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lch,rch,key,fa,dist;</span><br><span class="line">&#125;h[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span> <span class="keyword">or</span> ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> <span class="keyword">and</span> ch&lt;=<span class="string">'9'</span>)&#123;x=<span class="number">10</span>*x+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">int</span> tmp=x;x=y;y=tmp;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;       <span class="comment">//合并操作</span></span><br><span class="line"><span class="keyword">if</span>(!u <span class="keyword">or</span> !v) <span class="keyword">return</span> u+v;</span><br><span class="line"><span class="keyword">if</span>(h[u].key&gt;h[v].key <span class="keyword">or</span> (h[u].key==h[v].key <span class="keyword">and</span> u&gt;v)) swap(u,v);</span><br><span class="line"><span class="keyword">int</span> &amp;ul=h[u].lch,&amp;ur=h[u].rch;</span><br><span class="line">ur=merge(ur,v);</span><br><span class="line">h[ur].fa=u;</span><br><span class="line"><span class="keyword">if</span>(h[ul].dist&lt;h[ur].dist) swap(ul,ur);</span><br><span class="line">h[u].dist=h[ur].dist+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;     <span class="comment">//删除操作</span></span><br><span class="line"><span class="keyword">int</span> ul=h[u].lch,ur=h[u].rch;</span><br><span class="line">h[u].key=<span class="number">-1</span>;h[ul].fa=<span class="number">0</span>;h[ur].fa=<span class="number">0</span>;</span><br><span class="line">merge(ul,ur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;         <span class="comment">//查询操作</span></span><br><span class="line"><span class="keyword">return</span> h[x].fa?find(h[x].fa):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">h[<span class="number">0</span>].dist=<span class="number">-1</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,n)</span><br><span class="line">h[i].key=read();</span><br><span class="line">rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line"><span class="keyword">int</span> opt,x,y;</span><br><span class="line">opt=read(),x=read();</span><br><span class="line"><span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">y=read();</span><br><span class="line"><span class="keyword">if</span>(h[x].key!=<span class="number">-1</span> &amp;&amp; h[y].key!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> p=find(x),q=find(y);</span><br><span class="line"><span class="keyword">if</span>(p!=q) merge(p,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>(h[x].key==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=find(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h[p].key);</span><br><span class="line">erase(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://www.luogu.org/problemnew/show/P3377" target="_blank" rel="noopener">洛谷 P3377 【模板】左偏树（可并堆）</a></p>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 左偏树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【模板】莫队算法</title>
      <link href="/2018/05/11/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/05/11/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p><del>莫队算法，简单说就是基于分块进行暴力</del></p><blockquote><p>莫队算法，是由前国家队队长莫涛在役时创造的，为数不多几种在役选手在比赛或平时训练中创造并广为流传使用的算法之一。</p></blockquote><p>此算法在OI界具有极高的人气，据说能解决一切区间处理问题，<del>当然我这种蒟蒻却只能板子题做做</del>，让我们通过下面的题目简单了解一下莫队算法。<br><a id="more"></a></p><hr><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>有 n 个物品，分属于不同的类别，给出m个区间，求在各个区间中连续两次取出相同类别的物品的概率，最简分数表示，若概率为0则输出0/1。（n,m&lt;=50000）</p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，我们需要两个指针 l 和 r 来指示当前区间的位置，用 sum[ ] 数组存放当前区间各类别数量，ans 为区间结果，ans 的分母是所有的组合数 (r - l + 1) (r - l + 1)（为什么不是 (r - l + 1) (r - l) 呢？<del>我也不知道，题目数据就是这样的。。</del>），而分子是各个类别的sum[ ]的平方的累加和，根据其中任意一个区间的 ans 求出相邻区间的 ans。</p><blockquote><p>这里相邻区间定义为当前区间的 l - 1 或 l + 1 或 r - 1 或 r + 1<br>以 l + 1 为例，如下图：<br><img src="https://s1.ax1x.com/2018/05/11/C0oiGD.png" alt="C0oiGD.png"><br>我们将 l + 1,此时 sum[green] - 1，区间总数也 - 1，这时你会发现改变一次的时间复杂度竟然是O( 1 )？！<br>其他的改变也是同理</p></blockquote><p>当然这样是远远不够的，若是逐个区间暴力枚举，复杂度是O( n ^ 2 )，太高了呀<br>这时需要引入变量 unit = sqrt( n )，用它来进行分块（将 n 分为 sqrt( n ) 个区域），并用 ad[ i ] 来存储 i 所在的区间，这样，进行指针跳动时，最多只需要 2 * sqrt( n ) 次就能到达目标，大大优于之前的 n 次。</p><p>最后再次致敬莫涛大神！！</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50050</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll m,ll n)</span></span>&#123;<span class="keyword">while</span>(m&gt;<span class="number">0</span>)&#123;ll c=n%m;n=m;m=c;&#125;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow2</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mo</span>&#123;</span><span class="keyword">int</span> l,r,cnt;ll A,B;&#125;ask[MAXN];   <span class="comment">//存储区间信息</span></span><br><span class="line"><span class="comment">//A,B分别存储结果的分子和分母</span></span><br><span class="line"><span class="keyword">int</span> n,m,col[MAXN],unit,ad[MAXN];</span><br><span class="line">ll sum[MAXN],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Mo a,Mo b)</span></span>&#123;    <span class="comment">//优化时间复杂度</span></span><br><span class="line"><span class="keyword">return</span> ad[a.l]==ad[b.l]?a.r&lt;b.r:a.l&lt;b.l;</span><br><span class="line">&#125;       <span class="comment">//左指针为第一关键字</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Mo a,Mo b)</span></span>&#123;<span class="keyword">return</span> a.cnt&lt;b.cnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">revise</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span></span>&#123;     <span class="comment">//每次改变并维护ans和sum[ ]</span></span><br><span class="line">ans-=pow2(sum[col[x]]);</span><br><span class="line">sum[col[x]]+=add;</span><br><span class="line">ans+=pow2(sum[col[x]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">unit=<span class="built_in">sqrt</span>(n);</span><br><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">col[i]=read();</span><br><span class="line">ad[i]=i/unit+<span class="number">1</span>;     <span class="comment">//分块</span></span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">ask[i].l=read(),ask[i].r=read();</span><br><span class="line">ask[i].cnt=i;          <span class="comment">//记录原顺序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(ask+<span class="number">1</span>,ask+m+<span class="number">1</span>,cmp1);     <span class="comment">//减少指针总变换次数</span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,m)&#123;   <span class="comment">//执行操作</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;ask[i].l) revise(l,<span class="number">-1</span>),++l;</span><br><span class="line"><span class="keyword">while</span>(l&gt;ask[i].l) revise(l<span class="number">-1</span>,<span class="number">1</span>),--l;</span><br><span class="line"><span class="keyword">while</span>(r&lt;ask[i].r) revise(r+<span class="number">1</span>,<span class="number">1</span>),++r;</span><br><span class="line"><span class="keyword">while</span>(r&gt;ask[i].r) revise(r,<span class="number">-1</span>),--r;</span><br><span class="line"><span class="keyword">if</span>(ask[i].l==ask[i].r)&#123;      <span class="comment">//输出0/1</span></span><br><span class="line">ask[i].A=<span class="number">0</span>;</span><br><span class="line">ask[i].B=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ask[i].A=ans-(ask[i].r-ask[i].l+<span class="number">1</span>);</span><br><span class="line">ask[i].B=<span class="number">1L</span>L*(ask[i].r-ask[i].l+<span class="number">1</span>)*(ask[i].r-ask[i].l);</span><br><span class="line">ll tmp=gcd(ask[i].A,ask[i].B);     <span class="comment">//最简</span></span><br><span class="line">ask[i].A/=tmp;</span><br><span class="line">ask[i].B/=tmp;</span><br><span class="line">&#125;</span><br><span class="line">sort(ask+<span class="number">1</span>,ask+m+<span class="number">1</span>,cmp2);     <span class="comment">//按照原排序输出</span></span><br><span class="line">rep(i,<span class="number">1</span>,m)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,ask[i].A,ask[i].B);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">BZOJ 2038 [2009国家集训队]小Z的袜子(hose)</a></p>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【模板】非旋Treap</title>
      <link href="/2018/05/09/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%9D%9E%E6%97%8BTreap/"/>
      <url>/2018/05/09/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%9D%9E%E6%97%8BTreap/</url>
      <content type="html"><![CDATA[<h3 id="概念与基本性质"><a href="#概念与基本性质" class="headerlink" title="概念与基本性质"></a>概念与基本性质</h3><blockquote><p>Treap = Tree + Heap，即是一棵同时满足二叉搜索树和堆性质的二叉树<br>Treap 有一个随机附加域满足堆的性质，其结构相当于以随机数据插入的二叉搜索树<br>其基本操作的期望时间复杂度为 O(log n)</p></blockquote><p>相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。</p><a id="more"></a><hr><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote><ol><li>插入和删除</li><li>访问某位置</li><li>查询某数所在的位置</li></ol></blockquote><hr><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>本题目的是构造名次树来维护一个有序序列<br>为了在保证堆的性质的同时进行如上操作，我们引入下列函数：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cut</span><span class="params">(u, k)</span></span>      <span class="comment">//将以 u 为根节点的子树在第 k 个节点后切开，并返回切开后两树根节点。</span></span><br><span class="line"><span class="function"><span class="title">merge</span><span class="params">(l, r)</span></span>    <span class="comment">//在维护堆性质的同时将的两棵 Treap 合并为一棵，并返回合并后的根节点。</span></span><br></pre></td></tr></table></figure></p><p>每次cut的位置大概如下：<br><img src="https://s1.ax1x.com/2018/05/09/CwPhzn.png" alt="CwPhzn.png"></p><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><blockquote><p>插入 - insert = cut + merge + merge<br>删除 - delete = split + split + merge ⇒ O(log n)<br>排名查询/数值查询 - search ：通过二叉排序树的性质进行查找<br>前驱 - last：将所有比 x 小的数切下，找到其中最大的数后，再合并<br>后继 - next：将所有比 x 小的数（包括）切下，在剩下的树中找出最小的数后，再合并</p></blockquote><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(re i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tnode</span>&#123;</span>     <span class="comment">//记录节点状态</span></span><br><span class="line"><span class="keyword">int</span> l,r,val,siz,heap;</span><br><span class="line"><span class="comment">//l,r为节点左右子树，val节点数值 ，siz节点子树大小，heap随机生成</span></span><br><span class="line">&#125; t[<span class="number">100100</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aft</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll f=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">do</span>&#123;ch=getchar();<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(ch&lt;<span class="string">'0'</span> <span class="keyword">or</span> ch&gt;<span class="string">'9'</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> <span class="keyword">and</span> ch&lt;=<span class="string">'9'</span>);</span><br><span class="line"><span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//更新以u为根的子树的siz</span></span><br><span class="line">t[u].siz=t[t[u].l].siz+t[t[u].r].siz+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> aft <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//从以u为根的子树上割下k个点</span></span><br><span class="line">aft ans=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//记录切割后左右子树的根节点</span></span><br><span class="line"><span class="keyword">if</span>(!u) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">int</span> lsize=t[t[u].l].siz+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(k&gt;=lsize)&#123;<span class="comment">//若需要切下的点比整个左子树多，从右子树继续割</span></span><br><span class="line">ans=cut(t[u].r,k-lsize);</span><br><span class="line">t[u].r=ans.l;</span><br><span class="line">ans.l=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans=cut(t[u].l,k);</span><br><span class="line">t[u].l=ans.r;</span><br><span class="line">ans.r=u;</span><br><span class="line">&#125;</span><br><span class="line">update(u);<span class="comment">//更新以u为根节点的子树的siz</span></span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//返回左右子树根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;       <span class="comment">//将两棵树合并（按照heap值（小根堆））并返回根节点</span></span><br><span class="line"><span class="keyword">if</span>(!l) <span class="keyword">return</span> r;<span class="comment">//若左子树为空，返回右子树</span></span><br><span class="line"><span class="keyword">if</span>(!r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(t[l].heap&lt;t[r].heap)&#123;    <span class="comment">//若左子树根节点heap比右子树小，将右子树与左子树的右儿子merge</span></span><br><span class="line">t[l].r=merge(t[l].r,r);</span><br><span class="line">update(l);</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//左子树与右子树左儿子merge</span></span><br><span class="line">t[r].l=merge(l,t[r].l);</span><br><span class="line">update(r);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;    <span class="comment">//查询有多少个数严格比x小</span></span><br><span class="line"><span class="keyword">int</span> tmp=root,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tmp)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;t[tmp].val)&#123;</span><br><span class="line">ans+=t[t[tmp].l].siz+<span class="number">1</span>;</span><br><span class="line">tmp=t[tmp].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tmp=t[tmp].l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//插入操作</span></span><br><span class="line">t[++cnt].val=x;</span><br><span class="line">t[cnt].heap=rand();  <span class="comment">//随机生成heap值，使树保持相对平衡</span></span><br><span class="line">t[cnt].siz=<span class="number">1</span>;</span><br><span class="line">aft p=cut(root,rank(x));</span><br><span class="line"><span class="comment">//查找x在树中的rank，将比x小的数从树中切下</span></span><br><span class="line">root=merge(merge(p.l,cnt),p.r);</span><br><span class="line"><span class="comment">//先将x与左子树合并，再将左子树和右子树合并，并更新根节点Root</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;      <span class="comment">//删除操作</span></span><br><span class="line">aft p1=cut(root,rank(x));</span><br><span class="line">aft p2=cut(p1.r,<span class="number">1</span>);</span><br><span class="line">root=merge(p1.l,p2.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//在以u为根节点的树中，找第x小的数</span></span><br><span class="line"><span class="keyword">int</span> tmp=u;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> val=t[t[tmp].l].siz+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x==val) <span class="keyword">return</span> t[tmp].val;</span><br><span class="line"><span class="keyword">if</span>(x&lt;val) tmp=t[tmp].l;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x-=val;</span><br><span class="line">tmp=t[tmp].r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sma</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//查找第一个比x小的数</span></span><br><span class="line">aft p=cut(root,rank(x));<span class="comment">//将所有比x小的数切下</span></span><br><span class="line"><span class="keyword">int</span> ans=find(p.l,t[p.l].siz);<span class="comment">//查询切下的数中最大的</span></span><br><span class="line">root=merge(p.l,p.r);          <span class="comment">//合并</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lar</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;      <span class="comment">//查找第一个比x大的数</span></span><br><span class="line">aft p=cut(root,rank(x+<span class="number">1</span>));<span class="comment">//将所有比x小的数（包括）切下</span></span><br><span class="line"><span class="keyword">int</span> ans=find(p.r,<span class="number">1</span>);<span class="comment">//查询剩下的数中最小的</span></span><br><span class="line">root=merge(p.l,p.r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read();</span><br><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line"><span class="keyword">int</span> opt,x;</span><br><span class="line">opt=read(),x=read();</span><br><span class="line"><span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: ins(x); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: del(x); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rank(x)+<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find(root,x)); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sma(x)); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lar(x)); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://www.luogu.org/problemnew/show/P3369" target="_blank" rel="noopener">洛谷 P3369 【模板】普通平衡树（Treap/SBT）</a></p>]]></content>
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡树,Treap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【杂谈】Hello World!</title>
      <link href="/2018/05/08/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Hello%20World!/"/>
      <url>/2018/05/08/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Hello%20World!/</url>
      <content type="html"><![CDATA[<p>经过了整整一天的调试<br><del>在@<a href="https://xianyu626.github.io/" target="_blank" rel="noopener">北咸冥鱼</a> 的帮助下</del><br>博客总算是建好了<br>接下来应该会发一些算法题解之类的吧…</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
